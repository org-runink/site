name: Generate Blog Article

on:
  # Trigger when issue is opened with 'blog-request' label
  issues:
    types: [opened, labeled]
  # Keep repository_dispatch for Slack webhook integration
  repository_dispatch:
    types: [generate_blog]
  # Keep manual trigger as fallback
  workflow_dispatch:
    inputs:
      topic:
        description: "Blog topic to generate"
        required: true
        type: string

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  generate-blog:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull Blog Generator Image
        run: docker pull ghcr.io/org-runink/blogen:v1.1.1

      - name: Ensure output directories exist
        run: |
          mkdir -p content/blog
          mkdir -p static/images/blog

      - name: Extract Context & Topic
        id: topic
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;
            let topic = "";
            let richContext = "";
            let slug = "";
            let issueNumber = "";

            if (eventName === 'issues') {
              const issue = context.payload.issue;
              const title = issue.title;
              const body = issue.body || "";
              
              issueNumber = issue.number;
              
              // 1. Get Topic from Title (strip prefix)
              // Matches "[Blog Request]: " or just takes the whole title
              topic = title.replace(/^\[Blog Request\]:\s*/i, "").trim();
              
              // 2. Parse Form Body (Markdown)
              // Helper to extract section content
              const extractSection = (header) => {
                const regex = new RegExp(`### ${header}\\s+([\\s\\S]*?)(?=(###|$))`, 'i');
                const match = body.match(regex);
                return match ? match[1].trim() : "";
              };
              
              const businessChallenge = extractSection("Business Challenge / Opportunity"); // Fallback if they used the field
              const links = extractSection("Reference Links \\(Optional\\)");
              const audience = extractSection("Target Decision Maker");
              const valueDriver = extractSection("Primary Value Driver");
              
              // If title was generic "Blog Request", try to use the field
              if ((!topic || topic.toLowerCase() === "blog request") && businessChallenge) {
                topic = businessChallenge;
              }
              
            // Output
            core.setOutput('topic', topic);
            core.setOutput('slug', slug);
            if (issueNumber) core.setOutput('issue_number', issueNumber);

            // New separate context outputs
            core.setOutput('audience', audience || "");
            core.setOutput('value_driver', valueDriver || "");
            core.setOutput('context_links', links === "No response" ? "" : links || "");

      - name: Run Blog Generation with Docker
        id: blog_gen
        run: |
          # Capture the blog generation output
          OUTPUT=$(docker run --rm \
            -v ${{ github.workspace }}/content:/app/content \
            -v ${{ github.workspace }}/static:/app/static \
            -e TAVILY_API_KEY=${{ secrets.TAVILY_API_KEY }} \
            ghcr.io/org-runink/blogen:v1.1.1 \
            --content-dir /app/content/blog \
            --image-dir /app/static/images/blog \
            -t "${{ steps.topic.outputs.topic }}" \
            --audience "${{ steps.topic.outputs.audience }}" \
            --value-driver "${{ steps.topic.outputs.value_driver }}" \
            --context "${{ steps.topic.outputs.context_links }}" 2>&1)

          echo "$OUTPUT"

          # Extract LinkedIn posts JSON from output
          # Look for content between markers
          LINKEDIN_JSON=$(echo "$OUTPUT" | sed -n '/üì± LINKEDIN_POSTS_START/,/üì± LINKEDIN_POSTS_END/p' | sed '1d;$d')

          # If no JSON found (fallback), create default structure
          if [ -z "$LINKEDIN_JSON" ]; then
            echo "‚ö†Ô∏è No LinkedIn JSON found in output, creating default..."
            SLUG="${{ steps.topic.outputs.slug }}"
            TOPIC="${{ steps.topic.outputs.topic }}"
            BLOG_URL="https://www.runink.org/blog/${SLUG}/"
            
            LINKEDIN_JSON=$(cat <<EOF
            {
              "company_post": {
                "text": "üöÄ New Article: ${TOPIC}\\n\\nRead more: ${BLOG_URL}\\n\\n#AI #Logistics"
              },
              "personal_post": {
                "text": "I just published a new article on ${TOPIC}. Check it out: ${BLOG_URL}"
              }
            }
          EOF
            )
          fi

          # Save to environment for next steps (multiline string)
          echo "linkedin_posts<<EOF" >> $GITHUB_OUTPUT
          echo "$LINKEDIN_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Validate article quality
        run: |
          SLUG="${{ steps.topic.outputs.slug }}"
          ARTICLE_FILE="content/blog/${SLUG}.md"

          # Check frontmatter exists
          if ! grep -q "^---$" "$ARTICLE_FILE"; then
            echo "‚ùå Invalid frontmatter"
            exit 1
          fi

          # Check required fields
          for field in title description slug author date tags; do
            if ! grep -q "^${field}:" "$ARTICLE_FILE"; then
              echo "‚ùå Missing required field: $field"
              exit 1
            fi
          done

          # Check minimum content length (should be substantial)
          WORD_COUNT=$(wc -w < "$ARTICLE_FILE")
          if [ "$WORD_COUNT" -lt 800 ]; then
            echo "‚ùå Article too short: $WORD_COUNT words (minimum 800)"
            exit 1
          fi

          echo "‚úÖ Article validation passed"
          echo "   Word count: $WORD_COUNT"

      - name: Extract Post Content for Slack
        id: post_content
        run: |
          LINKEDIN_JSON='${{ steps.blog_gen.outputs.linkedin_posts }}'

          # Extract using jq, remove quotes
          COMPANY_POST=$(echo "$LINKEDIN_JSON" | jq -r '.company_post.text')
          PERSONAL_POST=$(echo "$LINKEDIN_JSON" | jq -r '.personal_post.text')

          # Escape newlines for Slack JSON payload
          # We use a trick to escape content safely for JSON inclusion
          echo "company_post<<EOF" >> $GITHUB_OUTPUT
          echo "$COMPANY_POST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "personal_post<<EOF" >> $GITHUB_OUTPUT
          echo "$PERSONAL_POST" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "üìù Add blog: ${{ steps.topic.outputs.topic }}"
          branch: "blog-auto/${{ steps.topic.outputs.slug }}"
          title: "üìù Blog: ${{ steps.topic.outputs.topic }}"
          body: |
            This PR adds a new blog post generated by AI.

            **Topic:** ${{ steps.topic.outputs.topic }}
            **Triggered by:** ${{ github.event_name == 'issues' && format('Issue #{0}', steps.topic.outputs.issue_number) || 'Manual trigger' }}

            ## Files Added
            - `content/blog/${{ steps.topic.outputs.slug }}.md`
            - `static/images/blog/${{ steps.topic.outputs.slug }}.png`

            Please review the content and diagrams before merging.
          labels: "automated-content"

      - name: Comment on issue (success)
        if: success() && github.event_name == 'issues' && steps.topic.outputs.issue_number
        uses: actions/github-script@v7
        with:
          script: |
            const slug = '${{ steps.topic.outputs.slug }}';
            const prNumber = '${{ steps.create_pr.outputs.pull-request-number }}';
            const prUrl = '${{ steps.create_pr.outputs.pull-request-url }}';

            let message = `‚úÖ **Blog Article Generated Successfully!**\n\nüìÅ **Files Generated:**\n- \`content/blog/${slug}.md\`\n- \`static/images/blog/${slug}.png\`\n\n`;

            if (prNumber) {
              message += `üîÄ **Pull Request Created:** #${prNumber}\n${prUrl}\n\nPlease review and merge the PR to publish the article.`;
            } else {
              message += `‚úÖ **Changes Committed Directly**\nüîó **Preview:** https://www.runink.org/blog/${slug}/\n\nThe site will be deployed shortly.`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.topic.outputs.issue_number }},
              body: message
            });

            // Close the issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.topic.outputs.issue_number }},
              state: 'closed',
              labels: ['blog-request', 'completed']
            });

      - name: Comment on issue (failure)
        if: failure() && github.event_name == 'issues' && steps.topic.outputs.issue_number
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.topic.outputs.issue_number }},
              body: `‚ùå **Blog Generation Failed**\n\n‚ö†Ô∏è Please check the GitHub Actions logs for details:\nhttps://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\n\nKeeping this issue open for retry.`
            });

      - name: Send LinkedIn Post Suggestions to Slack
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            TOPIC="${{ steps.topic.outputs.topic }}"
            SLUG="${{ steps.topic.outputs.slug }}"
            BLOG_URL="https://www.runink.org/blog/${SLUG}/"
            PR_URL="${{ steps.create_pr.outputs.pull-request-url }}"
            
            COMPANY_POST='${{ steps.post_content.outputs.company_post }}'
            PERSONAL_POST='${{ steps.post_content.outputs.personal_post }}'
            
            # Send to Slack
            curl -X POST "$SLACK_WEBHOOK_URL" \
              -H 'Content-Type: application/json' \
              -d "{
              \"text\": \"üìù New Blog Published - LinkedIn Promotion Ready\",
              \"blocks\": [
                {
                  \"type\": \"header\",
                  \"text\": {
                    \"type\": \"plain_text\",
                    \"text\": \"üìù New Blog Article Ready for Promotion\"
                  }
                },
                {
                  \"type\": \"section\",
                  \"fields\": [
                    {
                      \"type\": \"mrkdwn\",
                      \"text\": \"*Topic:*\n${TOPIC}\"
                    },
                    {
                      \"type\": \"mrkdwn\",
                      \"text\": \"*Blog URL:*\n<${BLOG_URL}|View Article>\"
                    }
                  ]
                },
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*PR for Review:*\n<${PR_URL}|View Pull Request>\"
                  }
                },
                {
                  \"type\": \"divider\"
                },
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*üì¢ LinkedIn Company Page Post:*\n\\\`\\\`\\\`${COMPANY_POST}\\\`\\\`\\\`\"
                  }
                },
                {
                  \"type\": \"divider\"
                },
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*üîÅ Your Personal Repost Message:*\n\\\`\\\`\\\`${PERSONAL_POST}\\\`\\\`\\\`\"
                  }
                },
                {
                  \"type\": \"context\",
                  \"elements\": [
                    {
                      \"type\": \"mrkdwn\",
                      \"text\": \"‚úèÔ∏è Feel free to customize these messages before posting!\"
                    }
                  ]
                }
              ]
            }"
          fi
